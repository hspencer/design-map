<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="d3.v7.min.js"></script>
    <title>Mapa del Diseño 3D</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Nunito", sans-serif;
        background-color: #ffffff; /* Fondo blanco */
      }
      canvas {
        display: block;
      }
      .controls {
        position: absolute;
        bottom: 1em;
        left: 1em;
        background: rgba(255, 255, 255, 0.8);
        padding: 1em;
        z-index: 10;
      }
      .label {
        fill: #000;
        text-anchor: middle;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <label>
        <input type="checkbox" id="toggleLabels" /> Mostrar etiquetas
      </label>
      <label>
        <input type="range" id="linkLength" min="10" max="300" value="100" />
        Largo de enlaces
      </label>
      <label>
        <input
          type="range"
          id="linkStrength"
          min="0"
          max="3"
          step="0.1"
          value="0.5"
        />
        Fuerza de enlaces
      </label>
    </div>

    <!-- Importmap para las dependencias -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      // Cargar las dependencias de Three.js y OrbitControls
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      async function loadDataAndInitialize() {
        try {
          // Configuración inicial de Three.js
          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          camera.position.set(0, 0, 300); // Alejar la cámara

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setClearColor(0xffffff); // Fondo blanco
          document.body.appendChild(renderer.domElement);

          // Controles de órbita para navegar en el espacio 3D
          const controls = new OrbitControls(camera, renderer.domElement);

          // Habilitar zoom
          controls.enableZoom = true;

          // Ajustar la velocidad del zoom
          controls.zoomSpeed = 1.2;

          // Habilitar rotación y pan (si es necesario)
          controls.enableRotate = true;
          controls.enablePan = true;

          // Geometría y material para los nodos
          const geometry = new THREE.SphereGeometry(5, 32, 32);
          const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
          const nodes = [];

          // Cargar los datos desde CSV con D3
          const data = await d3.csv(
            "https://docs.google.com/spreadsheets/d/e/2PACX-1vRH7srxOeUb950beVHfXg6RckjZL1axbyHBfoR6oXbGhpdX2F2-1bUpN6a64LqmHd01QsHEH_c0Kawa/pub?gid=1339882215&single=true&output=csv"
          );

          console.log("Datos CSV cargados:", data); // Verificar que los datos se cargan

          // cuantificación de conexiones
          const nodeConnections = {}; // Almacenar cuántas conexiones tiene cada nodo
          data.forEach((row) => {
            Object.keys(row).forEach((column) => {
              if (column.startsWith("Relación") && row[column]) {
                if (!nodeConnections[row[column]]) {
                  nodeConnections[row[column]] = 0;
                }
                nodeConnections[row[column]] += 1;
              }
            });
          });

          // Creación de nodos
          data.forEach((d) => {
            const node = new THREE.Mesh(geometry, material);
            node.position.set(
              Math.random() * 200 - 100,
              Math.random() * 200 - 100,
              Math.random() * 200 - 100
            );
            node.userData = {
              materia: d.Materia,
              connections: nodeConnections[d.Materia] || 1,
            };
            nodes.push(node);
            scene.add(node);
          });

          // Creación de enlaces
          const links = [];
          data.forEach((row) => {
            Object.keys(row).forEach((column) => {
              if (column.startsWith("Relación") && row[column]) {
                links.push({
                  source: row.Materia,
                  target: row[column],
                });
              }
            });
          });

          // Añadir etiquetas con D3 y mantenerlas orientadas hacia la cámara
          const svg = d3
            .select("body")
            .append("svg")
            .attr("width", window.innerWidth)
            .attr("height", window.innerHeight)
            .style("position", "absolute")
            .style("top", 0)
            .style("left", 0)
            .style("pointer-events", "none"); 

          const labels = svg
            .selectAll("text")
            .data(nodes)
            .enter()
            .append("text")
            .attr("class", "label")
            .text((d) => d.userData.materia || `Nodo`)
            .attr(
              "font-size",
              (d) => `${Math.sqrt(d.userData.connections) * 10}px`
            )
            .attr("fill", "black");

          // Configurar simulación de fuerza
          const simulation = d3
            .forceSimulation(nodes)
            .force(
              "link",
              d3
                .forceLink(links)
                .id((d) => d.userData.materia)
                .distance(100)
            )
            .force("charge", d3.forceManyBody().strength(-200))
            .force(
              "center",
              d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2)
            );

          // Actualizar posiciones en cada tick de la simulación
          simulation.on("tick", () => {
            nodes.forEach((node) => {
              node.position.x = node.x;
              node.position.y = node.y;
            });
            updateLabels();
          });

          // Función para actualizar etiquetas
          function updateLabels() {
            labels.each(function (d) {
              const vector = new THREE.Vector3(
                d.position.x,
                d.position.y,
                d.position.z
              );
              vector.project(camera);
              const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
              const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
              d3.select(this).attr("x", x).attr("y", y);
            });
          }

          // Función unificada de renderización de la escena y actualización de etiquetas
          function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            updateLabels(); // Incluye la actualización de etiquetas dentro del ciclo de animación principal
          }

          // Llamar solo a la función de animación principal
          animate();

          // Controles de fuerza y largo de enlaces
          document
            .getElementById("linkStrength")
            .addEventListener("input", function () {
              const strength = +this.value;
              simulation.force("link").strength(strength);
              simulation.alpha(1).restart();
            });

          document
            .getElementById("linkLength")
            .addEventListener("input", function () {
              const length = +this.value;
              simulation.force("link").distance(length);
              simulation.alpha(1).restart();
            });

          // Evento de redimensionado de ventana
          window.addEventListener("resize", function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            svg
              .attr("width", window.innerWidth)
              .attr("height", window.innerHeight);
          });
        } catch (error) {
          console.error(
            "Error al cargar los datos CSV o inicializar Three.js:",
            error
          );
        }
      }

      // Llamar a la función de carga de datos y renderizado
      loadDataAndInitialize();
    </script>
  </body>
</html>
