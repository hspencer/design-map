<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="d3.v7.min.js"></script>
    <title>Mapa del Diseño 3D</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Nunito", sans-serif;
        background-color: #ffffff; /* Fondo blanco */
      }
      canvas {
        display: block;
      }
      .controls {
        position: absolute;
        bottom: 1em;
        left: 1em;
        background: rgba(255, 255, 255, 0.8);
        padding: 1em;
        z-index: 10;
      }
      .label {
        fill: #000;
        text-anchor: middle;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <label>
        <input type="checkbox" id="toggleLabels" /> Mostrar etiquetas
      </label>
      <label>
        <input type="range" id="linkLength" min="10" max="300" value="100" />
        Largo de enlaces
      </label>
      <label>
        <input
          type="range"
          id="linkStrength"
          min="0"
          max="3"
          step="0.1"
          value="0.5"
        />
        Fuerza de enlaces
      </label>
    </div>

    <!-- Importmap para las dependencias -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      async function loadDataAndInitialize() {
        try {
          // Configuración inicial de Three.js
          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          camera.position.set(0, 0, 300); // Alejar la cámara
          scene.fog = new THREE.Fog(0xffffff, 500, 1000); // Aumentar la distancia para que los objetos no queden ocultos

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setClearColor(0xffffff); // Fondo blanco
          document.body.appendChild(renderer.domElement);

          // Controles de órbita para navegar en el espacio 3D
          const controls = new OrbitControls(camera, renderer.domElement);
          controls.enableZoom = true;
          controls.zoomSpeed = 1.2;
          controls.enableRotate = true;
          controls.enablePan = true;

          // Cargar los datos desde CSV con D3
          const data = await d3.csv(
            "https://docs.google.com/spreadsheets/d/e/2PACX-1vRH7srxOeUb950beVHfXg6RckjZL1axbyHBfoR6oXbGhpdX2F2-1bUpN6a64LqmHd01QsHEH_c0Kawa/pub?gid=1339882215&single=true&output=csv"
          );
          console.log("Datos CSV cargados:", data); // Verificar que los datos se cargan

          // Cuantificación de conexiones
          const nodeConnections = {};

          // Recorrer todas las filas para contar las conexiones desde cada tema
          data.forEach((row) => {
            const tema = row.Materia;

            if (!nodeConnections[tema]) {
              nodeConnections[tema] = 0;
            }

            // Sumar conexiones desde las relaciones en las columnas
            Object.keys(row).forEach((column) => {
              if (column.startsWith("Relación") && row[column]) {
                const relacion = row[column];

                // Sumar una conexión desde el tema actual a otro tema
                nodeConnections[tema] += 1;

                // Si la relación es con otro tema, sumarle también a ese tema
                if (!nodeConnections[relacion]) {
                  nodeConnections[relacion] = 0;
                }
                nodeConnections[relacion] += 1;
              }
            });
          });

          // Creación de nodos tridimensionales para la simulación D3
          const nodosD3 = data.map((d) => ({
            id: d.Materia,
            x: Math.random() * 200 - 100,
            y: Math.random() * 200 - 100,
            z: Math.random() * 400 - 200, // Añadimos el eje Z aleatoriamente
            connections: nodeConnections[d.Materia] || 1,
          }));

          // Creación de enlaces de datos para D3
          const d3Links = [];
          data.forEach((row) => {
            Object.keys(row).forEach((column) => {
              if (column.startsWith("Relación") && row[column]) {
                d3Links.push({
                  source: row.Materia,
                  target: row[column],
                });
              }
            });
          });

          // Añadir etiquetas con D3
          const svg = d3
            .select("body")
            .append("svg")
            .attr("width", window.innerWidth)
            .attr("height", window.innerHeight)
            .style("position", "absolute")
            .style("top", 0)
            .style("left", 0)
            .style("pointer-events", "none");

          const labels = svg
            .selectAll("text")
            .data(nodosD3)
            .enter()
            .append("text")
            .attr("class", "label")
            .text((d) => d.id)
            .attr("font-size", (d) => `${8 + Math.min(d.connections, 32)}px`)
            .attr("fill", "black");

          // Crear material para los enlaces
          const linkMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
          const links = [];

          // Crear enlaces 3D como líneas en Three.js
          d3Links.forEach((link) => {
            const sourceNode = nodosD3.find((n) => n.id === link.source);
            const targetNode = nodosD3.find((n) => n.id === link.target);

            if (sourceNode && targetNode) {
              const linkGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z),
                new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z),
              ]);
              const line = new THREE.Line(linkGeometry, linkMaterial);
              scene.add(line);
              links.push({ line, sourceNode, targetNode });
            }
          });

          // Simulación de D3 en 3D
          const simulation = d3
            .forceSimulation(nodosD3)
            .force(
              "link",
              d3
                .forceLink(d3Links)
                .id((d) => d.id)
                .distance(100)
            )
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(0, 0))
            .force("z", d3.forceManyBody().strength(-200)); // Añadimos fuerza para el eje Z

          // En cada tick, actualizar las posiciones en 3D
          simulation.on("tick", () => {
            labels.each(function (d) {
              const vector = new THREE.Vector3(d.x, d.y, d.z);
              vector.project(camera);
              const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
              const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
              d3.select(this).attr("x", x).attr("y", y);
            });

            links.forEach((link) => {
              const { sourceNode, targetNode, line } = link;
              const positions = line.geometry.attributes.position.array;

              // Actualizar posiciones del enlace en Three.js
              positions[0] = sourceNode.x;
              positions[1] = sourceNode.y;
              positions[2] = sourceNode.z;
              positions[3] = targetNode.x;
              positions[4] = targetNode.y;
              positions[5] = targetNode.z;

              line.geometry.attributes.position.needsUpdate = true;
            });
          });

          // Función de renderizado continuo
          function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
          }
          animate();

          // Controles de fuerza y largo de enlaces
          document
            .getElementById("linkStrength")
            .addEventListener("input", function () {
              const strength = +this.value;
              simulation.force("link").strength(strength);
              simulation.alpha(1).restart();
            });

          document
            .getElementById("linkLength")
            .addEventListener("input", function () {
              const length = +this.value;
              simulation.force("link").distance(length);
              simulation.alpha(1).restart();
            });

          // Controlar el estado del checkbox para mostrar etiquetas o enlaces
          document
            .getElementById("toggleLabels")
            .addEventListener("change", function () {
              const showLabels = this.checked;

              if (showLabels) {
                // Mostrar solo las etiquetas, ocultar los enlaces
                links.forEach((link) => {
                  link.line.visible = false;
                });
                labels.attr("visibility", "visible");
              } else {
                // Mostrar los enlaces y ocultar las etiquetas
                links.forEach((link) => {
                  link.line.visible = true;
                });
                labels.attr("visibility", "hidden");
              }

              // Asegurarse de que la simulación y el renderizado continúen
              simulation.alpha(1).restart(); // Reiniciar simulación
              animate(); // Asegurarse de que la animación continúa
            });

          // Evento de redimensionado de ventana
          window.addEventListener("resize", function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            svg
              .attr("width", window.innerWidth)
              .attr("height", window.innerHeight);
          });
        } catch (error) {
          console.error(
            "Error al cargar los datos CSV o inicializar Three.js:",
            error
          );
        }
      }

      // Llamar a la función de carga de datos y renderizado
      loadDataAndInitialize();
    </script>
  </body>
</html>
