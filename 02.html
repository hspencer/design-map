<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="d3.v7.min.js"></script>
    <title>Mapa del Diseño 3D</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Nunito", sans-serif;
        background-color: #ffffff; /* Fondo blanco */
      }
      canvas {
        display: block;
      }
      .controls {
        position: absolute;
        bottom: 1em;
        left: 1em;
        background: rgba(255, 255, 255, 0.8);
        padding: 1em;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <div class="controls">
      <label>
        <input type="checkbox" id="toggleLabels" /> Mostrar etiquetas
      </label>
      <label>
        <input type="range" id="linkLength" min="10" max="300" value="100" />
        Largo de enlaces
      </label>
      <label>
        <input
          type="range"
          id="linkStrength"
          min="0"
          max="3"
          step="0.1"
          value="0.5"
        />
        Fuerza de enlaces
      </label>
    </div>

    <!-- Importmap para las dependencias -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

      async function loadDataAndInitialize() {
        try {
          // Inicializar escena, cámara y controles
          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          camera.position.set(0, 0, 300);
          
          scene.fog = new THREE.Fog(0xffffff, 500, 1000); // Nieble para efecto visual

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setClearColor(0xffffff); // Fondo blanco
          document.body.appendChild(renderer.domElement);

          // Controles de cámara
          const controls = new OrbitControls(camera, renderer.domElement);
          controls.enableZoom = true;
          controls.enableRotate = true;
          controls.enablePan = true;

          // Cargar los datos desde CSV con D3
          const data = await d3.csv(
            "https://docs.google.com/spreadsheets/d/e/2PACX-1vRH7srxOeUb950beVHfXg6RckjZL1axbyHBfoR6oXbGhpdX2F2-1bUpN6a64LqmHd01QsHEH_c0Kawa/pub?gid=1339882215&single=true&output=csv"
          );
          console.log("Datos CSV cargados:", data);

          // Cuantificación de conexiones
          const nodeConnections = {};
          data.forEach((row) => {
            const tema = row.Materia;

            if (!nodeConnections[tema]) {
              nodeConnections[tema] = 0;
            }

            // Sumar conexiones desde las relaciones en las columnas
            Object.keys(row).forEach((column) => {
              if (column.startsWith("Relación") && row[column]) {
                const relacion = row[column];

                nodeConnections[tema] += 1;

                if (!nodeConnections[relacion]) {
                  nodeConnections[relacion] = 0;
                }
                nodeConnections[relacion] += 1;
              }
            });
          });

          // Crear nodos D3 con posiciones aleatorias en 3D
          const nodesD3 = data.map((d) => ({
            id: d.Materia,
            x: Math.random() * 200 - 100,
            y: Math.random() * 200 - 100,
            z: Math.random() * 400 - 200,
            connections: nodeConnections[d.Materia] || 1,
          }));

          // Creación de enlaces de datos para D3
          const d3Links = [];
          data.forEach((row) => {
            Object.keys(row).forEach((column) => {
              if (column.startsWith("Relación") && row[column]) {
                d3Links.push({
                  source: row.Materia,
                  target: row[column],
                });
              }
            });
          });

          // Crear material para los enlaces
          const linkMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
          const links = [];

          // Crear enlaces en Three.js
          d3Links.forEach((link) => {
            const sourceNode = nodesD3.find((n) => n.id === link.source);
            const targetNode = nodesD3.find((n) => n.id === link.target);

            if (sourceNode && targetNode) {
              const linkGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(sourceNode.x, sourceNode.y, sourceNode.z),
                new THREE.Vector3(targetNode.x, targetNode.y, targetNode.z),
              ]);
              const line = new THREE.Line(linkGeometry, linkMaterial);
              scene.add(line);
              links.push({ line, sourceNode, targetNode });
            }
          });

          // Cargar la fuente
          const fontLoader = new FontLoader();
          fontLoader.load(
            "font.json",
            (font) => {
              nodesD3.forEach((node) => {
                const textGeo = new TextGeometry(node.id, {
                  font: font,
                  size: 8 + Math.min(node.connections, 32),
                  height: 0.5,
                });
                const textMaterial = new THREE.MeshBasicMaterial({
                  color: 0x000000,
                });
                const textMesh = new THREE.Mesh(textGeo, textMaterial);

                textMesh.position.set(node.x, node.y, node.z);
                scene.add(textMesh);

                node.textMesh = textMesh;
              });
            }
          );

          const simulation = d3
            .forceSimulation(nodesD3)
            .force(
              "link",
              d3
                .forceLink(d3Links)
                .id((d) => d.id)
                .distance(100)
            )
            .force("charge", d3.forceManyBody().strength(-200))
            .force("center", d3.forceCenter(0, 0))
            .force("z", d3.forceManyBody().strength(-200));

          simulation.on("tick", () => {
            links.forEach((link) => {
              const { sourceNode, targetNode, line } = link;
              const positions = line.geometry.attributes.position.array;
              positions[0] = sourceNode.x;
              positions[1] = sourceNode.y;
              positions[2] = sourceNode.z;
              positions[3] = targetNode.x;
              positions[4] = targetNode.y;
              positions[5] = targetNode.z;
              line.geometry.attributes.position.needsUpdate = true;
            });
          });

          // Función de renderizado continuo
// Función de renderizado continuo
            function animate() {
            requestAnimationFrame(animate);
            
            // Hacer que los textos sigan la cámara
            nodesD3.forEach((node) => {
                if (node.textMesh) {
                node.textMesh.lookAt(camera.position); // Alinear textos hacia la cámara
                }
            });

            controls.update();
            renderer.render(scene, camera);
            }
          animate();

          // Controles de fuerza y largo de enlaces
          document
            .getElementById("linkStrength")
            .addEventListener("input", function () {
              const strength = +this.value;
              simulation.force("link").strength(strength);
              simulation.alpha(1).restart(); // Reiniciar la simulación con la nueva fuerza
            });

          document
            .getElementById("linkLength")
            .addEventListener("input", function () {
              const length = +this.value;
              simulation.force("link").distance(length);
              simulation.alpha(1).restart(); // Reiniciar la simulación con la nueva distancia de enlaces
            });

          // Controlar el estado del checkbox para mostrar etiquetas o enlaces
          document
            .getElementById("toggleLabels")
            .addEventListener("change", function () {
              const showLabels = this.checked;

              if (showLabels) {
                // Ocultar los enlaces y mostrar solo las etiquetas
                links.forEach((link) => {
                  link.line.visible = false;
                });
                scene.children.forEach((child) => {
                  if (child.geometry instanceof TextGeometry) {
                    child.visible = true; // Mostrar los textos
                  }
                });
              } else {
                // Mostrar los enlaces y ocultar las etiquetas
                links.forEach((link) => {
                  link.line.visible = true;
                });
                scene.children.forEach((child) => {
                  if (child.geometry instanceof TextGeometry) {
                    child.visible = false; // Ocultar los textos
                  }
                });
              }

              // Asegurarse de que la simulación y el renderizado continúen
              simulation.alpha(1).restart(); // Reiniciar simulación
              animate(); // Continuar animación
            });

          // Evento de redimensionado de ventana
          window.addEventListener("resize", function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          });
        } catch (error) {
          console.error(
            "Error al cargar los datos CSV o inicializar Three.js:",
            error
          );
        }
      }

      // Llamar a la función de carga de datos y renderizado
      loadDataAndInitialize();
    </script>
  </body>
</html>
